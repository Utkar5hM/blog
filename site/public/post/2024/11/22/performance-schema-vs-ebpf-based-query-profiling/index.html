<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Performance Schema vs eBPF-based Query Profiling | Utkarsh M</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <header class="site-title-main">
      Utkarsh M
    </header>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="post-container">
  <div class="post-date">2024/11/22</div>
  <h1 class="post-title">Performance Schema vs eBPF-based Query Profiling</h1>
</div>

<main>
<p>During my time at IRIS NITK, I had the opportunity to work with a talented group of peers exploring distributed strategies for MariaDB. While I couldn’t dive deeply into every aspect, I gained valuable exposure—particularly to eBPF, which several colleagues were using for research and internal tools. That sparked my interest in the technology.</p>
<p>After completing my internship, I began building an eBPF-based monitoring tool to understand the space better. Although the initial version was completed, I didn’t revisit it for over a year.</p>
<p>Recently, I decided to revisit the tool and evaluate its performance and usefulness.</p>
<p><a href="https://github.com/Utkar5hM/mariadb-ebpf-exporter">Project GitHub Link</a></p>
<h2 id="how-it-works">How It Works</h2>
<p>The <code>mariadb-ebpf-exporter</code> collects query latency metrics by attaching an eBPF probe to the <code>dispatch_command()</code> function—present in both MySQL and MariaDB. It then normalizes queries for grouping and exposes the results as Prometheus metrics, which can be visualized using Grafana.</p>
<p>I chose <code>libbpfgo</code> due to its CO-RE (Compile Once, Run Everywhere) capabilities and because I wanted to build the userspace in Go. One limitation I faced was that compiled MariaDB/MySQL binaries often have mangled function names. Since <code>libbpfgo</code> doesn&rsquo;t support resolving these easily (unlike <code>bpftrace</code>), I wrote a build script that uses the <code>nm</code> tool to extract the function name and compile the eBPF object accordingly. The BPF binary is then embedded in the Go code using Go’s <code>embed</code> package, ensuring compatibility with the target DB version.</p>
<p>To make setup easier, I containerized the entire compilation and runtime process with Docker. This allows running the tool against both host and containerized databases by joining the appropriate namespaces.</p>
<h2 id="performance-considerations">Performance Considerations</h2>
<p>There are a few aspects to consider before benchmarking:</p>
<ul>
<li>Query normalization uses regular expressions, which can be resource-intensive. Offloading normalization/export to a different system could reduce overhead.</li>
<li>As this is a custom tool, its performance will naturally depend on implementation quality.</li>
</ul>
<p>I also experimented with filtering to only capture slower queries (e.g., &gt;200ms or &gt;1000ms). While this approach sounds logical, <a href="https://www.percona.com/blog/performance_schema-vs-slow-query-log/">Percona’s blog</a> explains why it may not always be the best idea. Still, I tried both approaches and compared the results.</p>
<h2 id="benchmarking-setup">Benchmarking Setup</h2>
<h3 id="sysbench-scripts">Sysbench Scripts</h3>
<p>My initial idea was to create a workload where CPU and memory usage hovered around 50–60% under raw conditions, to observe how the tool impacts performance. However, maintaining that balance proved tricky. I eventually settled on using default sysbench scripts, which max out CPU/memory usage and allow us to measure throughput via the number of transactions.</p>
<pre><code class="language-sh">sysbench oltp_common --db-driver=mysql --table-size=100000 --mysql-user=root --mysql-password=L0CK3D_1N --mysql-port=3306 --mysql-host=10.128.0.3 --mysql-db=sysbenchtest prepare
sysbench oltp_read_write --db-driver=mysql --table-size=100000 --mysql-user=root --mysql-password=L0CK3D_1N --mysql-port=3306 --mysql-host=10.128.0.3 --mysql-db=sysbenchtest --threads=12 --report-interval=1 run
</code></pre>
<p>I also disabled indexing to deliberately slow down the queries and better visualize the metrics.</p>
<p><img src="/assets/img/other/ebpf-perf/grafana-db.jpeg" alt="grafana-dashboard-screenshot"></p>
<p>Prometheus query used in Grafana:</p>
<pre><code class="language-sh">rate(ebpf_exporter_query_latencies_histogram_sum[1m])/rate(ebpf_exporter_query_latencies_histogram_count[1m])
</code></pre>
<p>Before every test, I ran the following cleanup command:</p>
<pre><code class="language-sh">sysbench oltp_common --db-driver=mysql --table-size=100000 --mysql-user=root --mysql-password=L0CK3D_1N --mysql-port=3306 --mysql-host=10.128.0.3 --mysql-db=sysbenchtest cleanup
</code></pre>
<h3 id="performance-schema">Performance Schema</h3>
<p>For configuring performance schema, I followed this guide from the MySQL documentation: <a href="https://dev.mysql.com/doc/mysql-perfschema-excerpt/5.7/en/performance-schema-query-profiling.html">Query Profiling Using Performance Schema</a></p>
<p>An example of the latency metrics collected is shown below:</p>
<p><img src="/assets/img/other/ebpf-perf/perf_schema_ex.jpeg" alt="performance-schema-query-latency-ss"></p>
<h3 id="process-exporter">Process Exporter</h3>
<p>I had the <a href="https://github.com/ncabatoff/process-exporter">Process Exporter</a> running to log CPU and memory usage, but unfortunately missed the Prometheus retention window and couldn’t recover the data. While I don’t have screenshots to share, I still used the tool during testing.</p>
<h3 id="system-configuration">System Configuration</h3>
<p>All tests were performed on 2 GCP instances with the following configuration:</p>
<ul>
<li><code>e2-standard-2</code> (2 vCPU, 1 core, 8 GB memory)</li>
<li>OS: Debian</li>
</ul>
<h2 id="benchmarking-results">Benchmarking Results</h2>
<p>Initially, collecting all queries (0ms threshold) caused high CPU usage:</p>
<p><img src="/assets/img/other/ebpf-perf/htop.jpeg" alt="htop-ss"></p>
<p>However, filtering queries with latency over 200ms significantly reduced resource usage, which was also reflected in the benchmark results.</p>
<h3 id="results">Results</h3>
<p>Each test was run three times, and results were averaged:</p>
<table>
  <thead>
      <tr>
          <th>Test</th>
          <th>Read Queries</th>
          <th>Write Queries</th>
          <th>Total Queries</th>
          <th>Transactions</th>
          <th>Total Time</th>
          <th>Total Events</th>
          <th>Min Latency</th>
          <th>Avg Latency</th>
          <th>Max Latency</th>
          <th>95th Latency</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ebpf</td>
          <td>2108526</td>
          <td>602436</td>
          <td>3012180</td>
          <td>150609</td>
          <td>300.0397</td>
          <td>150609</td>
          <td>8.34</td>
          <td>47.81</td>
          <td>375.13</td>
          <td>89.27</td>
      </tr>
      <tr>
          <td>ebpf &gt; 200ms</td>
          <td>2155041</td>
          <td>615726</td>
          <td>3078630</td>
          <td>153931.5</td>
          <td>300.0355</td>
          <td>153931.5</td>
          <td>7.42</td>
          <td>46.77</td>
          <td>378.97</td>
          <td>94.10</td>
      </tr>
      <tr>
          <td>performance_schema</td>
          <td>1821535.33</td>
          <td>520438.67</td>
          <td>2602193.33</td>
          <td>130109.67</td>
          <td>300.05895</td>
          <td>130109.67</td>
          <td>8.65</td>
          <td>56.51</td>
          <td>318.80</td>
          <td>86.79</td>
      </tr>
      <tr>
          <td>raw</td>
          <td>2120234.67</td>
          <td>605781.33</td>
          <td>3028906.67</td>
          <td>151445.33</td>
          <td>300.03707</td>
          <td>151445.33</td>
          <td>8.21</td>
          <td>47.55</td>
          <td>365.94</td>
          <td>90.60</td>
      </tr>
  </tbody>
</table>
<h3 id="visualizations">Visualizations</h3>
<p>Charts generated from Google Sheets:</p>
<p><img src="/assets/img/other/ebpf-perf/nt.png" alt="no-of-transactions"></p>
<p><img src="/assets/img/other/ebpf-perf/nq.png" alt="no-of-queries"></p>
<p><img src="/assets/img/other/ebpf-perf/al.png" alt="average-latency"></p>
<p><img src="/assets/img/other/ebpf-perf/lazy.jpeg" alt="chill-guy"></p>

</main>

  <footer>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="//cdn.jsdelivr.net/npm/@xiee/utils/js/math-code.min.js" defer></script>
<script src="//cdn.jsdelivr.net/npm/katex/dist/katex.min.js" defer></script>
<script src="//cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js" defer></script>
<script src="//cdn.jsdelivr.net/npm/@xiee/utils/js/render-katex.js" defer></script>

<script src="//cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js" defer></script>

  
  <hr/>
  © <a href="https://yihui.org">Yihui Xie</a> 2017 &ndash; 2025 | <a href="https://github.com/yihui">Github</a> | <a href="https://twitter.com/xieyihui">Twitter</a>
  
  </footer>
  </body>
</html>

